package code;

import java.security.NoSuchAlgorithmException;

public class Account {
    String address;
    String balance;
    String hash;

    public Account(String entry) {
        if (entry == null) { // for padded entries
            address = null;
            balance = null;
            hash = null;
        } else { // for "normal" string entries
            String[] accountInfo = entry.split(" ", 2);
            address = accountInfo[0];
            balance = accountInfo[1];
            try {
                hash = Encrypt.toHexString(Encrypt.getSHA(address + balance));
            } catch (NoSuchAlgorithmException e) {
                System.err.println("Unable to get SHA-256 hash for leaf nodes");
                System.exit(1);
            }
        }
    }

    public String toString() {
        return String.format("Address: %s\nBalance: %s\nHash: %s\n\n", address, balance, hash);
    }
}
package code;

import java.util.ArrayList;

public class App {
    public static void main(String[] args) {
        // Makes sure that only 2 arguments are provided
        int argLength = args.length;
        if (argLength > 1) {
            System.err.println(
                    "Too many arguments were provided. Please only provide the filename with a list of addresses and balances");
            System.exit(1);
        } else if (argLength < 1) {
            System.err.println(
                    "Not enough arguments were provided. Please provide the filename with a list of addresses and balances");
            System.exit(1);
        }

        // Each element in the ledger is a concatenated string of the balance and
        // transaction
        ArrayList<Account> ledger = Input.parseFile(args[0]);
        // Print out the ledger (ArrayList) using prebuild toString() method
        // System.out.println(ledger.toString());
        System.out.println("Merkle Root: " + Hash.getMerkleRoot(ledger, 0, ledger.size() - 1));
    }
}
package code;

import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

/**
 * Calculate SHA-256 for a given string
 * Source: https://www.geeksforgeeks.org/sha-256-hash-in-java/
 */
class Encrypt {
    public static byte[] getSHA(String input) throws NoSuchAlgorithmException {
        // Static getInstance method is called with hashing SHA
        MessageDigest md = MessageDigest.getInstance("SHA-256");

        // digest() method called
        // to calculate message digest of an input
        // and return array of byte
        return md.digest(input.getBytes(StandardCharsets.UTF_8));
    }

    public static String toHexString(byte[] hash) {
        // Convert byte array into signum representation
        BigInteger number = new BigInteger(1, hash);

        // Convert message digest into hex value
        StringBuilder hexString = new StringBuilder(number.toString(16));

        // Pad with leading zeros
        while (hexString.length() < 32) {
            hexString.insert(0, '0');
        }

        return hexString.toString();
    }

    // Driver code
    // public static void main(String args[]) {
    //     try {
    //         System.out.println("HashCode Generated by SHA-256 for:");

    //         String s1 = "GeeksForGeeks";
    //         System.out.println("\n" + s1 + " : " + toHexString(getSHA(s1)));

    //         String s2 = "hello world";
    //         System.out.println("\n" + s2 + " : " + toHexString(getSHA(s2)));
    //     }
    //     // For specifying wrong message digest algorithms
    //     catch (NoSuchAlgorithmException e) {
    //         System.out.println("Exception thrown for incorrect algorithm: " + e);
    //     }
    // }
}
package code;

import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;

/**
 * Computes the Merkle root given a array of leaf nodes (assume sorted) Similar
 * to a merge sort in terms of divide and conquer
 */
public class Hash {
    public static String getMerkleRoot(ArrayList<Account> ledger, int start, int end) {
        // If recursion reaches a leaf, return an empty string
        if (start == end) {

            if (ledger.get(start).address == null) {
                return "";
            }
            return ledger.get(start).hash;
        }

        int mid = (start + end) / 2;

        // Gets the left and right hashes of the tree
        String leftHash = getMerkleRoot(ledger, start, mid);
        String rightHash = getMerkleRoot(ledger, mid + 1, end);
        String concatHash = leftHash + rightHash;

        // If both left and right hashes are empty (Hash attempt of padded values),
        // return nothing, since the hash of the empty string "" is still valid and it
        // would modify the final resulting hash
        if (concatHash == "") {
            return "";
        }

        // Get the SHA-256 hash of the leaf
        try {
            return Encrypt.toHexString(Encrypt.getSHA(concatHash));
        } catch (NoSuchAlgorithmException e) {
            System.err.println("ERROR: Unable to get SHA-256 hash");
            System.exit(1);
        }
        return "";
    }
}
package code;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;

public class Input {

    /**
     * Parses a ledger file and creates an ArrayList of Accounts
     * 
     * @param: String of file name
     * @exception: File not found
     * @return: Account ArrayList of file contents
     */

    public static ArrayList<Account> parseFile(String filename) {
        // The file object to read from
        File myFile = new File(filename);
        Scanner fileScanner = null;
        try {
            // if the file exists
            fileScanner = new Scanner(myFile);
        } catch (FileNotFoundException e) {
            System.err.println("ERROR: File not found.");
            e.printStackTrace();
        }

        // the ArrayList to be returned
        ArrayList<Account> myList = new ArrayList<Account>();

        while (fileScanner.hasNextLine()) {
            String data = fileScanner.nextLine();
            Account newAcc = new Account(data);
            myList.add(newAcc);
        }

        // close the file scanner
        fileScanner.close();

        // padding
        int levels = log2(myList.size());
        int maxSize = (int) Math.pow(2, levels);
        while (myList.size() != maxSize) {
            Account padAcc = new Account(null);
            myList.add(padAcc);
        }
        return myList;
    }

    // Function to calculate the
    // log base 2 of an integer
    // Source:
    // https://www.geeksforgeeks.org/how-to-calculate-log-base-2-of-an-integer-in-java/
    public static int log2(int N) {
        // calculate log2 N indirectly
        // using log() method
        int result = (int) Math.ceil(Math.log(N) / Math.log(2));
        return result;
    }
}
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

// Java program to calculate SHA hash value 

class Test {
    public static byte[] getSHA(String input) throws NoSuchAlgorithmException {
        // Static getInstance method is called with hashing SHA
        MessageDigest md = MessageDigest.getInstance("SHA-256");

        // digest() method called
        // to calculate message digest of an input
        // and return array of byte
        return md.digest(input.getBytes(StandardCharsets.UTF_8));
    }

    public static String toHexString(byte[] hash) {
        // Convert byte array into signum representation
        BigInteger number = new BigInteger(1, hash);

        // Convert message digest into hex value
        StringBuilder hexString = new StringBuilder(number.toString(16));

        // Pad with leading zeros
        while (hexString.length() < 32) {
            hexString.insert(0, '0');
        }

        return hexString.toString();
    }

    // Driver code
    public static void main(String args[]) {
        try {
            System.out.println("HashCode Generated by SHA-256 for:");

            String s1 = "";
            System.out.println("\n" + s1 + " : " + toHexString(getSHA(s1)));
        }
        // For specifying wrong message digest algorithms
        catch (NoSuchAlgorithmException e) {
            System.out.println("Exception thrown for incorrect algorithm: " + e);
        }
    }
}